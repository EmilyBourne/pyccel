# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------------------#
# This file is part of Pyccel which is released under MIT License. See the LICENSE file or #
# go to https://github.com/pyccel/pyccel/blob/master/LICENSE for full license details.     #
#------------------------------------------------------------------------------------------#
"""
Module describing all elements of the AST needed to represent elements which appear in a Fortran-C binding
file.
"""

from pyccel.ast.basic import Basic
from pyccel.ast.core import CodeBlock, FunctionCall, Module
from pyccel.ast.core import FunctionAddress
from pyccel.ast.core import FunctionDef
from pyccel.ast.core import FunctionDefArgument, FunctionDefResult
from pyccel.ast.core import Assign
from pyccel.ast.core import Import
from pyccel.ast.core import AsName
from pyccel.ast.core import Allocate
from pyccel.ast.datatypes import DataType, NativeInteger
from pyccel.ast.variable import Variable
from pyccel.parser.scope import Scope

__all__ = (
    'BindCFunctionDef',
    'BindCFunctionDefArgument',
    'BindCFunctionDefResult',
    'BindCModule',
    'BindCPointer',
    'CLocFunc',
    'C_F_Pointer',
    'wrap_array',
    'wrap_module_array_var',
)


class BindCFunctionDef(FunctionDef):
    """
    Represents the definition of a C-compatible function.

    Contains the C-compatible version of the function which is
    used for the wrapper.
    As compared to a normal FunctionDef, this version contains
    arguments for the shape of arrays. It should be generated by
    calling `codegen.wrapper.FortranToCWrapper.wrap`.

    Parameters
    ----------
    *args : list
        See FunctionDef

    original_function : FunctionDef
        The function from which the c-compatible version was created

    **kwargs : dict
        See FunctionDef

    See Also
    --------
    pyccel.ast.core.FunctionDef
    """
    __slots__ = ('_original_function',)
    _attribute_nodes = (*FunctionDef._attribute_nodes, '_original_function')

    def __init__(self, *args, original_function, **kwargs):
        self._original_function = original_function
        super().__init__(*args, **kwargs)
        assert self.name == self.name.lower()
        assert all(isinstance(a, BindCFunctionDefArgument) for a in self._arguments)
        assert all(isinstance(a, BindCFunctionDefResult) for a in self._results)

    @property
    def original_function(self):
        """
        The function which is wrapped by this BindCFunctionDef.

        The original function which would be printed in pure Fortran which is not
        compatible with C.
        """
        return self._original_function

    @property
    def bind_c_arguments(self):
        """
        Get the BindCFunctionDefArguments of the function.

        Return a list of all the arguments passed to the function.
        These objects all have the type BindCFunctionDefArgument so
        shapes and strides are hidden.
        """
        return self._arguments

    @property
    def bind_c_results(self):
        """
        Get the BindCFunctionDefResults of the function.

        Return a list of all the results returned by the function.
        These objects all have the type BindCFunctionDefResult so
        shapes and strides are hidden.
        """
        return self._results

    @property
    def results(self):
        return [ai for a in self._results for ai in a.get_all_function_def_results()]

    @property
    def arguments(self):
        return [ai for a in self._arguments for ai in a.get_all_function_def_arguments()]

# =======================================================================================


class BindCFunctionDefArgument(FunctionDefArgument):
    """
    Stores all the information necessary to expose an argument to C code.

    Arguments of a C-compatible function may need additional information
    in order to fully construct the object. This class is mostly important
    for array objects. These objects must pass not only the data, but also
    meta-data. Namely the shape and strides for the array in each dimension.
    This information is stored in this class

    Parameters
    ----------
    var : Variable
        The variable being passed as an argument.

    scope : pyccel.parser.scope.Scope
        The scope in which any arguments to the function should be declared.
        This is used to create the shape and stride variables.

    original_arg_var : FunctionDefArgument
        The argument which was passed to the function currently being wrapped
        in a C-Fortran interface.

    **kwargs : dict
        See FunctionDefArgument.

    See Also
    --------
    pyccel.ast.core.FunctionDefArgument
    """
    __slots__ = ('_sizes', '_strides', '_original_arg_var', '_rank')
    _attribute_nodes = FunctionDefArgument._attribute_nodes + \
                        ('_sizes', '_strides', '_original_arg_var')

    def __init__(self, var, scope, original_arg_var, **kwargs):
        name = var.name
        self._rank = original_arg_var.rank
        sizes   = [scope.get_temporary_variable(NativeInteger(),
                            name=f'{name}_shape_{i+1}')
                   for i in range(self._rank)]
        strides = [scope.get_temporary_variable(NativeInteger(),
                            name=f'{name}_stride_{i+1}')
                   for i in range(self._rank)]
        self._sizes = sizes
        self._strides = strides
        self._original_arg_var = original_arg_var
        super().__init__(var, **kwargs)

    @property
    def original_function_argument_variable(self):
        """
        The argument which was passed to the function currently being wrapped.

        The FunctionDefArgument which was originally passed to the function
        currently being wrapped in a C-Fortran interface.
        """
        return self._original_arg_var

    @property
    def sizes(self):
        """
        The sizes of the array argument in each dimension.

        A tuple containing the variables which describe the number of
        elements along each dimension of an array argument. These values
        must be passed to any C-compatible function taking an array as an
        argument.
        """
        return self._sizes

    @property
    def strides(self):
        """
        The strides of the array argument in each dimension.

        A tuple containing the variables which describe the strides of
        an array argument in each dimension. These values must be passed to
        any C-compatible function taking an array as an argument.
        """
        return self._strides

    def get_all_function_def_arguments(self):
        """
        Get all arguments which must be printed to fully describe this argument.

        Get a list of all the arguments to the C-compatible function which are
        required in order to fully describe this argument. This includes the data
        for the object itself as well as any sizes or strides necessary to
        define arrays.

        Returns
        -------
        list
            A list of FunctionDefArguments which will be arguments of a BindCFunction.
        """
        args = [self]
        args += [FunctionDefArgument(size) for size in self.sizes]
        args += [FunctionDefArgument(stride) for stride in self.strides]
        return args

    def __repr__(self):
        if self.has_default:
            argument = str(self.name)
            value = str(self.value)
            return f'BindCFunctionDefArgument({argument}={value}, inout={self.inout})'
        else:
            return f'BindCFunctionDefArgument({repr(self.name)}, inout={self.inout})'

    @property
    def inout(self):
        """
        Indicates whether the argument may be modified by the function.

        True if the argument may be modified in the function. False if
        the argument remains constant in the function. For array arguments
        the inout status of the sizes and strides are also returned.
        """
        if self._rank:
            return [False] + [False, False]*self._rank
        else:
            return super().inout

# =======================================================================================


class BindCFunctionDefResult(FunctionDefResult):
    __slots__ = ('_sizes', '_original_res_var')
    _attribute_nodes = FunctionDefResult._attribute_nodes + \
                        ('_var', '_sizes', '_original_res_var')

    def __init__(self, var, original_res_var, sizes = (), **kwargs):
        self._sizes = sizes
        assert len(sizes) == original_res_var.rank
        self._original_res_var = original_res_var
        super().__init__(var, **kwargs)

    @property
    def original_function_result_variable(self):
        return self._original_res_var

    @property
    def sizes(self):
        return self._sizes

    def get_all_function_def_results(self):
        res = [self]
        res += [FunctionDefResult(size) for size in self.sizes]
        return res

# =======================================================================================

class BindCModule(Module):
    __slots__ = ('_orig_mod',)
    _attribute_nodes = ('_orig_mod',)

    def __init__(self, *args, original_module, **kwargs):
        self._orig_mod = original_module
        super().__init__(*args, **kwargs)

    @property
    def original_module(self):
        """ The module which was wrapped
        """
        return self._orig_mod

# =======================================================================================

class BindCPointer(DataType):
    """ Datatype representing a c pointer in fortran
    """
    __slots__ = ()
    _name = 'bindcpointer'

# =======================================================================================

class CLocFunc(Basic):
    """ Class representing the iso_c_binding function cloc which returns a valid
    C pointer to the location where an object can be found
    """
    __slots__ = ('_arg', '_result')
    _attribute_nodes = ()

    def __init__(self, argument, result):
        self._arg = argument
        self._result = result
        super().__init__()

    @property
    def arg(self):
        """ Object which will be pointed at
        """
        return self._arg

    @property
    def result(self):
        """ The variable in which the pointer is stored
        """
        return self._result

# =======================================================================================

class C_F_Pointer(Basic):
    __slots__ = ('_c_expr', '_f_expr', '_sizes')
    _attribute_nodes = ('_c_expr', '_f_expr', '_sizes')

    def __init__(self, c_expr, f_expr, sizes = ()):
        self._c_expr = c_expr
        self._f_expr = f_expr
        self._sizes = sizes
        super().__init__()

    @property
    def c_pointer(self):
        return self._c_expr

    @property
    def f_array(self):
        return self._f_expr

    @property
    def sizes(self):
        return self._sizes

# =======================================================================================


def wrap_array(var, scope, persistent):
    """ Function returning the code and local variables necessary to wrap an array

    Parameters
    ----------
    var : Variable
            The array to be wrapped
    scope : Scope
            The current scope (used to find valid names for variables)
    persistent : bool
            Indicates whether the variable is persistent in memory or
            if it needs copying to avoid dead pointers

    Results
    -------
    body : list
            A list describing the lines which must be printed to wrap the array
    variables : list
            A list of all new variables necessary to wrap the array. The list
            contains:
            - The C Pointer which wraps the array
            - Variables containing the sizes of the array
            - The Fortran pointer which will contain a copy of the Fortran data
              (unless the variable is persistent in memory)
    """
    bind_var = Variable(dtype=BindCPointer(),
                        name=scope.get_new_name('bound_'+var.name))
    sizes = [Variable(dtype=NativeInteger(), name=scope.get_new_name())
             for _ in range(var.rank)]
    assigns = [Assign(sizes[i], var.shape[i]) for i in range(var.rank)]
    variables = [bind_var, *sizes]
    if not persistent:
        ptr_var = var.clone(scope.get_new_name(var.name+'_ptr'),
                            memory_handling='alias')
        alloc = Allocate(ptr_var, shape=var.shape,
                         order=var.order, status='unallocated')
        copy = Assign(ptr_var, var)
        c_loc = CLocFunc(ptr_var, bind_var)
        variables.append(ptr_var)
        body = [*assigns, alloc, copy, c_loc]
    else:
        c_loc = CLocFunc(var, bind_var)
        body = [*assigns, c_loc]
    return body, variables

# =======================================================================================

def wrap_module_array_var(var, scope, mod):
    """
    Get a function which allows a module variable to be accessed.

    Create a function which exposes a module array variable to C.
    This allows the module variable to be accessed from the Python
    code.

    Parameters
    ----------
    var : Variable
            The array to be exposed.
    scope : Scope
            The current scope (used to find valid names for variables).
    mod : Module
            The module where the variable is defined.

    Returns
    -------
    FunctionDef
        A function which wraps an array and can be called from C.
    """
    func_name = 'bind_c_'+var.name.lower()
    func_scope = scope.new_child_scope(func_name)
    body, necessary_vars = wrap_array(var, func_scope, True)
    func_scope.insert_variable(necessary_vars[0])
    result_vars = [FunctionDefResult(v) for v in necessary_vars]
    import_mod = Import(mod.name, AsName(var,var.name), mod=mod)
    func = BindCFunctionDef(name = func_name,
                  body      = body,
                  arguments = [],
                  results   = result_vars,
                  imports   = [import_mod],
                  scope = func_scope,
                  original_function = None)
    return func
